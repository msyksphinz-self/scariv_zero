メモリアクセス
=============

MSRHのメモリアクセスの実装
--------------------------

MSRHはメモリアクセスのために2つのキューを使って命令の生存管理をしています。

- LDQ (LoaD Queue) : ロード命令に関する管理を行います
- STQ (STore Queue) : ストア命令に関する管理を行います。また、アトミック命令もこのキューを用いて管理を行います。


メモリアクセスパイプライン
--------------------------

LDQ / STQの命令は、必要なオペランドがすべて揃うとLSUパイプラインに挿入されます。
ここで、LDQ/STQはメモリアドレス生成に必要なオペランドが命令発行条件となり、ストア命令のストアデータは
LSUパイプラインへの発行条件には含まれません(メモリアドレスの生成とは別に、ストアデータまで揃った時点で
ストア命令は命令実行完了状態となり、コミットを待ちます)。

LSUパイプラインはEX0からEX3までのステージで構成されています。



LDQ / STQ間のハザード管理
-------------------------

LDQ/STQはそれぞれプログラム順に関係なく、オペランドのそろったものから順にパイプラインに投入されます。
このためLDQ/STQはお互いにハザードを発生させる可能性があります。ハザードの要因は、以下のようなものです。

- STQ内のストア命令が実行されるよりも早く、同じアドレスを参照する若いロード命令が実行される

このハザードを検出するために、ロード命令はLSUパイプラインを通過する際に、
常にSTQの全エントリに対して"フォワーディングチェック"が行われます。

STQのエントリについて、以下の条件がすべて満たされる場合、STQからのデータがLSUパイプライン中のロード命令にフォワードされます。

- STQのエントリがロード命令よりも古い
- STQエントリのアドレスが確定しており、ロード命令のアドレスと被っている
- STQエントリのストアデータが確定している

この場合、LSUパイプライン中のロード命令はフォワーディングデータを受け取り、実行が継続されます。

一方で、以下の場合はLDQ→STQでのハザードが発生します。

- STQのエントリがロード命令より古い、かつ
- STQエントリのアドレスが確定していない、または
- STQエントリのアドレスが確定しておりロード命令のアドレスと被っているが、ストアデータが確定していない

この場合LSUパイプライン内のロード命令にはハザードが通知され、
ロード命令はLDQに戻って再開を待ちます。
STQからLDQへ、 `resolve` 信号が渡されており、どのエントリが解決したかをLDQに
常に伝えています。この信号に基づいて、ハザードが発生しているエントリの全てが解消された場合、
当該ロード命令はLDQからLSUパイプラインに再投入されます。
