ROBと命令コミット
=================

ROB(Reorder Buffer)は、すべてのパイプラインを含むバックエンドに存在する
すべての命令の順序を管理するためのユニットです。
"Reorder"という名前の通り、アウトオブオーダで実行される命令を
プログラム順に戻すための機能を持っており、命令ムがどのような順番で
実行されたとしても、ROBにより最終的にプログラム順に戻されます。

ROBは、バックエンドによって実行が完了したら命令の情報を集め、プログラム順に
最終的な状態を決定します。
プログラム順序的にその完了した命令は"コミット"され、その命令の状態は確定します。
逆に言えば、"コミット"された命令の実行状態は元に戻すことはできず、
コミットされる前の命令は、たとえバックエンドパイプラインでの実行が完了していたとしても
"フラッシュ"操作により打ち消される可能性があります。

フロントエンドからディスパッチされた命令は、ROBにその命令が登録されます。
ROBは命令の状態を保持するエントリから構成されており、
一般的に複数のエントリを持っています。

SCARIVコアでは、ROBのエントリ数は再構成可能であり、1つのエントリが保持することのできる
命令数も再構成可能となっています。
SCARIV Standard構成ではROBのエントリ数は32、1エントリあたり5つの命令を保持することができます。

バックエンドパイプラインで命令を実行し計算結果やデータのロードが完了すると、
バックエンドパイプライン(正確には各パイプラインを制御するスケジューラ)はROBに対して
命令実行終了通知 (done通知) を転送します。

ROBは受け取ったdone信号をもとにどの命令が実行完了したのかを記録し、最も古いエントリの
登録されているすべての命令が実行完了すると、その命令を"コミット"状態とします。
コミット状態になったエントリはROBから削除されます。
コミット状態になると、どの命令がコミットされたかを示すコミット通知信号(`o_commit`)が設定され、
必要なユニットにコミット情報が通知されます。

このコミット情報は、PCのアップデートやコミット後のストア命令の動作などに使用されます。
また、検証環境においてはこのコミット通知信号の情報に基づいてISSとの一致比較が行われます。

ROBによる例外の管理
-------------------

ROBは例外の発生を管理します。
例外はバックエンドの命令パイプラインと、フロントエンドの両方で発生する可能性があります。
フロントエンドは、命令フェッチに関する例外の情報をROBに通知し、
バックエンドは命令に関する例外の情報を通知します。

ROBエントリは1エントリにつき複数の命令を格納しているため、1エントリの中で複数の命令が
例外を通知する可能性があります。
ROBはエントリ中の全ての命令が完了し、そのエントリが最もプログラム順序的に古くなると
コミットを行いますが、ROBはエントリ内に保持された例外情報の内最も若い命令が
発生させた例外を通知します。

例外には大きく分けて2種類があり、それぞれでコミット時の動作が異なります。

- Dead例外: その命令自体が無効となる例外です。
  命令アドレスミスアラインなどのメモリアクセス・命令フェッチに関する例外は、
  その例外が発生すると命令自体が無効化されます。
- Active例外: 命令は例外を発生させますが、その命令自体は有効です。
  例えばECALL例外は、ECALL命令実行時に発生し、ECALL命令自体にECALL例外の情報が
  付属しますが、ECALL命令自体はDeadとはなりません。

RISC-Vの例外仕様に定義された例外以外に、SCARIVはコア内のパイプラインを管理するための例外情報を
持っています。これはSILENT_FLUSHと呼ばれ、これもActive例外となります。
SILENT_FLUSH例外を発生させた命令は、その命令自体は有効ですが、後続のすべての命令が無効となり
パイプラインフラッシュが行われます。
PCなどのCPU上のステートはアップデートされず(つまりソフトウェア上からはSILENT_FLUSHの発生は見えません)、パイプラインフラッシュ後に、SILENT_FLUSHを発生させた命令の次の命令から実行が再開されます。

これは例えばCSR更新命令など、CSRレジスタがアップデートされた場合、
一度パイプラインをフラッシュし新しいCSRステートで命令を実行する場合などに
使用されます。
