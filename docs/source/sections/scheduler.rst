.. _scheduler:

命令発行スケジューラ
====================

命令発行スケジューラは、フロントエンドでデコードされた命令を一時的に格納し、
バックエンドでの実行管理を行う役割を持っています。
SCARIVはコア内で命令の種類毎に異なるスケジューラを持っており、命令の種類に応じて使用されるスケジューラが異なります。

同一種類の資源を複数持つタイプのコンフィグレーションでは、同一の命令種に対して複数のスケジューラが
使用される可能性があります。
例えば、ALU資源を複数個持つコンフィグレーションでは、
スケジューラはALUパイプラインの数だけ用意され、
どのスケジューラに対して命令が発行されるかは実装依存となります。

SCARIVでは、以下の命令種に応じてそれぞれスケジューラが用意されています。

- ALU
- BRU
- CSU

ただし、LSUのみは使用される上記の命令種で使用されるスケジューラと異なります。
LSUではロード命令とストア命令に応じて個別にスケジューラが実装されており、スケジューラの数は
LSUパイプラインの数とは無関係です。

スケジューラの実装
------------------

スケジューラはフロントエンドからディスパッチされた命令を受け取り、
バックエンドの実行パイプラインに渡すための役割を持っています。

スケジューラの役割は主に以下が挙げられます。

- 実行パイプラインに命令を渡すことができるかの管理
- 実行パイプライン終了後にROBに命令完了の通知

スケジューラには、一般的に複数の"命令管理エントリ"が搭載されており、
個別に命令のスケジューリングを行っています。
それぞれのエントリは、命令の順序と関係なくパイプラインに対する命令発行要求を
行うことができます(アウトオブオーダ実行)。

全てのエントリが命令で埋められると、スケジューラはフロントエンドに対してこれ以上命令を
受け取ることができないことを通知します。
この場合はフロントエンドが停止します。

スケジューラのパラメータ
------------------------

スケジューラ(`scariv_scheduler`)は以下のパラメータを持ちます。

- `IS_STORE` : メモリストア命令を管理するためのスケジューラかどうかを指定します
  - メモリストア命令である場合、命令発行の条件が異なります
- `ENTRY_SIZE` : スケジューラに含まれているエントリ数を示します
  - 全てのエントリを使い切ると、そのスケジューラにそれ以上命令を渡すことができません
- `IN_PORT_SIZE` : エントリに対して1サイクルで同時に格納することができる命令の数を示します
- `EN_OLDEST` : スケジューラの発行条件として、その命令が最も古い命令になった時のみ発行するスケジューリングを行います
  - つまり投機的実行は行いません。投機実行することができない、システムレジスタアクセス命令用のエントリなどで使用します。

スケジューラの実装
------------------

スケジューラは複数の命令を受け取りその発行条件を管理します。
新しい(複数の)命令がディスパッチされた時に、どのエントリに命令が格納されるのかを決定するために
ポインタが用意されています。
スケジューラ内のエントリはリングバッファとして作用し、これらのポインタはエントリの
終端まで到達すると、先頭のエントリにポインタが戻ります。

ポインタは2種類用意されています。

- `w_in_ptr` : ディスパッチされた命令の格納先を決めるためのポインタ
  - ポインタの先頭から順番に、ディスパッチされた命令の数だけポインタが進められる
- `w_out_ptr` : 完了していない最も古い命令を指し示すポインタ
  - このポインタの先頭が、最も優先度の高い命令発行エントリとなる

`w_in_ptr` は `w_out_ptr` を先行します。
`w_out_ptr` は `w_in_ptr` よりも先行することは出来ません。
また、 `w_in_ptr` と `w_out_ptr` の差分はエントリの数を超えることは出来ません。

新たな命令がディスパッチされると、ディスパッチされた命令の数だけ `w_in_ptr` が進めらます。
