GShare分岐予測器
==============

GShare分岐予測器は、グローバル分岐予測機の一種であり、現在のPCアドレスのみでなく全体的な分岐命令の結果列を使用して分岐予測を行います。

例えば以下のような命令列を考えます (以下は「コンピュータアーキテクチャ 定量的アプローチ 第5版」を引用した上でRISC-Vアーキテクチャに修正したものです)。

- C言語での実装

	if (aa & 1) {
	   aa = 0;
	   } else {
   aa = 1;
}
if (bb & 1) {
   bb = 0;
} else {
   bb = 1;
}
if (aa != bb) {
...
}


上記をコンパイルして生成したアセンブリコードが以下になります。

```asm
branch_count:
    li      t0, 5
    blt     a0, t0, .cut_aa
	li		a0, 0
    j       .bb_check
.cut_aa:
    li		a0, 1

.bb_check:
    blt     a1, t0, .cut_bb
	li		a1, 0
    j       .final_check
.cut_bb:
    li		a1, 1

.final_check:
    bne     a0, a1, .ret_false
    li      a0, 1
.ret_false:
    li      a0, 0
    ret
```

BNE命令によるaaとbbの比較は、それより前の2つの分岐命令`BLT`に依存します。2つのBLT命令の結果、分岐成立を1、分岐不成立を0とし、ビット列で表現すると、

```
00_0   // aa < 5成立, bb < 5成立 --> aa!=bb不成立
01_1   // aa < 5成立, bb < 5不成立 --> aa!=bb成立
10_1   // aa < 5不成立, bb < 5成立 --> aa!=bb成立
11_0   // aa < 5不成立, bb < 5不成立 --> aa!=bb不成立
```

このように、前の2つ分の分岐結果により最後の分岐命令の結果を予測することが出来ます。
分岐結果を管理するビット列をBHR(Branch History Table)と呼び、分岐予測はBHRとPCとのハッシュ関数(実装はXOR)によるインデックスを作成し、そのインデックスに基づいて
2ビット予測カウンタに対してアクセスを行います。

SCARIVにおけるGShareの実装
======================

Scarivは命令キャッシュのフェッチに3サイクルを要します。
- s0 : 命令キャッシュへPCの供給
- s1 : 命令キャッシュのHit/Missの判定
- s2 : 命令キャッシュからデータの取得



GShareによる複数命令の分岐予測
==============================


GShareは高度な分岐予測器ですが、その特性上BHRを1命令毎にアップデートする必要があります。

1キャッシュラインで複数の分岐命令が登場した際に以下のような弊害が発生します。

```
BR   a1, a2, label1  // 分岐1
ADD
BR   a3, a4, label2  // 分岐2
SUB
BR   a5, a6, label3  // 分岐3
```

分岐1が成立と予測した場合と不成立と予測した場合で、分岐2が使用できるBHRは変化します。

- 分岐1が成立と予測した場合の分岐2が使用するBHR   : `{xxxxxxx1}`
- 分岐1が不成立と予測した場合の分岐2が使用するBHR : `{xxxxxxx0}`

この分岐1の予測はGShareによるBimodalテーブルを参照した後にしか取得できず、
テーブル参照に1サイクルを要する場合、分岐2が分岐1と同じサイクルで予測することができなくなり、
性能に影響があります。

さらに分岐3が使用できるBHRは分岐1と分岐2の予測結果に依存するためより性能に影響があります。

- 分岐1が成立 / 分岐2が成立   : `{xxxxxx11}`
- 分岐1が成立 / 分岐2が不成立 : `{xxxxxx10}`
- 分岐1が不成立 / 分岐2が成立   : `{xxxxxx01}`
- 分岐1が不成立 / 分岐2が不成立 : `{xxxxxx00}`

このように、キャッシュブロックの中の分岐命令を同時に予測する必要がある場合に
性能に影響が出るため、そのままGShareのアルゴリズムを使用できません。

```
target hash    = (instruction address >> 2) xor (target >> 3)
target history = (target history << 2) xor target hash
```
